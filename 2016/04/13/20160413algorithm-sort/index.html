<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>常见排序算法总结 | Welcome to May's Blog</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">Welcome to May's Blog</a><span class="subtitle"></span><label id="toggle-menu" for="menu" onclick=""><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>常见排序算法总结</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2016-04-13</div><div class="post-categories"><a class="post-category-link" href="/categories/Study/">Study</a></div><div class="post-tags"><a class="post-tag-link" href="/tags/Algorithm/">Algorithm</a>/<a class="post-tag-link" href="/tags/C/">C</a>/<a class="post-tag-link" href="/tags/Sort/">Sort</a></div></div></div><article><div class="container post"><p>一些常见的排序算法总结，为了防止自己哪天忘了可以回顾下，算法代码都用C语言来写，毕竟自己学的第一门语言。</p>
<blockquote>
<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2></blockquote>
<p>这几个月面试了三四家公司，其中第一家</p>
<blockquote>
<p>面试官：知道有哪些排序算法吗<br>我：嗯，冒泡，插入，选择，快排，归并，桶排<br>面试官：恩好，下一题<br>我：。。。。</p>
</blockquote>
<p>如果他面试官按照常理出牌说说一下某某排序的具体思路，这就好玩了，因为有一半的我不会！！我在给自己挖坑，结果还没坑到自己。</p>
<p>还有一次面试</p>
<blockquote>
<p>面试官：解释一下冒泡算法<br>我：%&amp;￥%#……×&amp;%%￥%￥<br>面试官：额。。。恩。。。。下一题。</p>
</blockquote>
<p>结果证明我知道的排序算法都能解释的非常模糊，等于没讲，所以就整理一下思路，省的以后面试还是解释不清楚</p>
<p>为了方便说明，现在有一个数组arr，长度为n，然后按照从小到大进行排序</p>
<blockquote>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2></blockquote>
<p>该冒泡算法的时间复杂度是O(n<sup>2</sup>)</p>
<blockquote>
<h3 id="简单思路描述"><a href="#简单思路描述" class="headerlink" title="简单思路描述"></a>简单思路描述</h3></blockquote>
<p>首先arr[0]与arr[1]比较，如果arr[0]大于arr[1]则两者交换，否则不动，然后比较arr[1]与arr[2]，如果arr[1]大于arr[2]则两者交换，否则不动，以此类推，直到arr[n-1]与arr[n]比较处理完，此时最大的数就像冒泡泡那样移到arr[n]。此时第一轮循环结束，然后以此类推第二轮循环找出最大的移动arr[n-1]的位子，然后以此类推不断将最大的往后挪。</p>
<p>也就是说不断的访问要排序的数列，每次比较两个元素，如果这两个元素排列错误则交换过来，这样大的元素就慢慢移到后面。</p>
<p><img src="/image/20160413_1.gif" alt="图片摘自维基百科"></p>
<blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3></blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n-i<span class="number">-1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2></blockquote>
<p>选择排序的时间复杂度和冒泡排序一样都是O(n<sup>2</sup>)</p>
<blockquote>
<h3 id="简单思路描述-1"><a href="#简单思路描述-1" class="headerlink" title="简单思路描述"></a>简单思路描述</h3></blockquote>
<p>首先，找到数组中最小的，并将它与第一个交换，然后找到扫一遍找到第二个最小的，并将它与第二个数交换，然后以此类推数组就排序好了</p>
<p>也就是说在未排序的序列中找到最小的元素，放到起始位子，然后在剩余未排序的选取最小的元素，放到排好序列的最后，这样以此类推就排好了。</p>
<p><img src="/image/20160413_2.gif" alt="图片摘自维基百科"></p>
<blockquote>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3></blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, min, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[min] &gt; arr[j]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            arr[i] = arr[min];</span><br><span class="line">            arr[min] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2></blockquote>
<p>插入排序的时间复杂度也是O(n<sup>2</sup>)</p>
<p>排序，插入，还有冒泡，这三种算法是我最熟悉的，因为当初大一学C语言的时候，这三种排序考试必考，不会也得会啊。当然相应的也是最简单的排序方法，所以从时间复杂度来讲也是最耗时的=。=</p>
<blockquote>
<h3 id="简单描述"><a href="#简单描述" class="headerlink" title="简单描述"></a>简单描述</h3></blockquote>
<p>首先看arr[1]与arr[0]的大小关系，将两者的顺序从小到大排序，这样从arr[0]到arr[1]是排好的，然后将arr[2]插入到arr[0]到arr[1]这序列中，使arr[0]到arr[2]是有序的序列，然后是arr[4]插入进来，以此类推就成了有序的序列。</p>
<p>也就是说通过构建有序序列，对于位排序的数据在已排序中进行扫描，找到相应的位子插进去。</p>
<p><img src="/image/20160413_3.gif" alt="图片摘自维基百科"></p>
<blockquote>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3></blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j+<span class="number">1</span>]; j--) &#123;</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2></blockquote>
<p>个人感觉最重要的排序就是排序，然而现在才开始学习实在是惭愧=。=</p>
<p>时间复杂度为O(n*logn)，而且该算法在同为O(n*logn)的几种排序算法中效率更高。</p>
<blockquote>
<h3 id="简单描述-1"><a href="#简单描述-1" class="headerlink" title="简单描述"></a>简单描述</h3></blockquote>
<p>从大体上来说，该算法采用的是分治法的思想。详细步骤如下：</p>
<blockquote>
<p>1、从序列中挑选出一个基准，可以是第一个，也可以是最后一个，也可以是中间的，这里以取最后一个为例。<br>2、重新排列序列，将比基准大的放一边，比基准小的放另一边，这样基准就处于两边的中间位子。以最后一个为基准的话，首尾指针双管齐下，首先通过首指针往后扫描找到比基准大的，然后将其移到尾指针的位置，然后尾指针往前扫描直至找到比基准小的，将其移到首指针处，如此下去直至首尾指针相遇，此时首尾指针处就是基准存放的地方。更为详细白话的介绍<a href="http://blog.csdn.net/morewindows/article/details/6684558" target="_blank" rel="noopener">戳这里</a><br>3、然后对左右分区重复上述1、2操作</p>
</blockquote>
<p><img src="/image/20160413_4.gif" alt="图片摘自维基百科"></p>
<blockquote>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3></blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort_recurse</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag, left, right, i;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    i = rand()%(end-start) + start;</span><br><span class="line">    flag = arr[i];          <span class="comment">//flag选取随机数，避免O(n&lt;sup&gt;2&lt;/sup&gt;)的最坏情况</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*将选取的随机数与最后一个交换*/</span></span><br><span class="line">    i = arr[end];</span><br><span class="line">    arr[end] = flag;</span><br><span class="line">    flag = i;</span><br><span class="line"></span><br><span class="line">    left = start;</span><br><span class="line">    right = end;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= flag) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            arr[right] = arr[left];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= flag) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = flag;</span><br><span class="line">    quick_sort_recurse(arr, start, left<span class="number">-1</span>);</span><br><span class="line">    quick_sort_recurse(arr, left+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   quick_sort_recurse(arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2></blockquote>
<p>时间复杂度同样为O(n*logn)，该算法的效率也是非常不错的，只不过相比于快排，需要额外的存储空间。</p>
<blockquote>
<h3 id="简单描述-2"><a href="#简单描述-2" class="headerlink" title="简单描述"></a>简单描述</h3></blockquote>
<p>该算法也是典型的采用分治法。其思想简单的描述就是将排序好的两个序列合并成一个序列，要得到排序好的序列，就需要不断的将序列再平分，直至序列里面只有一个数字，此时序列肯定是有序的，然后再不断的合并上去，直至合并成一个有序的序列。</p>
<p>所以该算法的核心也就是如何有效的合并两个序列，由于序列是有序的，所以只要安排两个指向他们首部的指针，然后看两个指针指向的内容哪个小就取出来存在临时的序列中，并且指针向后移，然后接着比较两个指针指向的内容，直至某个指针指到末尾，然后另个序列的余下内容再接着补上。</p>
<p><img src="/image/20160413_5.gif" alt="图片摘自维基百科"></p>
<blockquote>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3></blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_recurse</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> temp[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid, left, right, merge;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    mid = (end-start) / <span class="number">2</span> + start;</span><br><span class="line">    merge_sort_recurse(arr, temp, start, mid);</span><br><span class="line">    merge_sort_recurse(arr, temp, mid+<span class="number">1</span>, end);</span><br><span class="line">    left = merge = start;</span><br><span class="line">    right = mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= mid &amp;&amp; right &lt;= end)</span><br><span class="line">        temp[merge++] = (arr[left] &lt; arr[right]) ? arr[left++] : arr[right++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= mid)</span><br><span class="line">        temp[merge++] = arr[left++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right &lt;= end)</span><br><span class="line">        temp[merge++] = arr[right++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (merge = start; merge &lt;= end; merge++)</span><br><span class="line">        arr[merge] = temp[merge];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">const</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp[n];</span><br><span class="line">    merge_sort_recurse(arr, temp, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2></blockquote>
<p>以上则是比较常用的排序算法，祝自己找到好的实习T_T</p>
<p>The End~</p>
</div><!-- comment system--><div class="container"><hr></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div><div class="footer">© 2019 <a href="/" rel="nofollow">may</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>